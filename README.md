# web_package
Ruby implementation of Signed HTTP Exchange format, allowing a browser to trust that a HTTP request-response pair was generated by the origin it claims.


## Ever thought of saving the Internet on a flash?

Easily-peasily.

Let's sign a pair of request/response and serve the bundle as `application/signed-exchange` - Chromium browsers understand what it means and unpack them smoothly.

For that we need a certificate with a special "CanSignHttpExchanges" extension, but for the purpose of this guide we will use just a self-signed one. Please refer [here](https://github.com/WICG/webpackage/tree/master/go/signedexchange#creating-our-first-signed-exchange) to create such.

Also we need an `https` cdn serving static certificate in `application/cert-chain+cbor` format. We can use `gen-certurl` tool from [here](https://github.com/WICG/webpackage/tree/master/go/signedexchange#creating-our-first-signed-exchange) to convert PEM certificate into this format, so we could than serve it from a cdn.

### Required environment variables
Having done the above-said we are now ready to assign required env vars:
```bash
export SXG_CERT_URL='https://my.cdn.com/cert.cbor' \
       SXG_CERT_PATH='/local/path/to/cert.pem' \
       SXG_PRIV_PATH='/local/path/to/priv.key'
```

### The very signing
And here is where the fun begins:
```ruby
require 'web_package'

# mimicking `Rack::Response` class
Response = Struct.new(:body, :headers, :status)

# this is the request/response pair
request  = 'https://foo.com/bar'
response = Response['<h1>Hello world!</h1>', {}, 200]

exchange = WebPackage::SignedHttpExchange.new(request, response)

exchange.headers
# => {"Content-Type"=>"application/signed-exchange;v=b3", "Cache-Control"=>"no-transform", "X-Content-Type-Options"=>"nosniff"}

exchange.body
# => "sxg1-b3\x00\x00\x13https://foo.com/bar\x00\x015\x00\x00\x8Clabel;cert-sha256=*+DoXYlCX+bFRyW65R3bFA2ICIz8Tyu54MLFUFo5tziA=*;cert-url=\"https://my-cdn.com/cert.cbor\";date=1556744158;expires=1557348958;integrity=\"digest/mi-sha256-03\";sig=*MEQCIGdIGAQtUT6xWDzVBcdmd05J46ctDgxhg7GRN0R4R0SaAiBRRfE+Yp76k2tJZQCRBfoIf9SMAAJj/uktw2SMYUa6qQ==*;validity-url=\"https://foo.com/bar\"\xA4FdigestX9mi-sha256-03=4QeUScOpSoJl7KJ47F11rSDHUTHZhDVwLiSLOWMcvqg=G:statusC200Pcontent-encodingLmi-sha256-03Vx-content-type-optionsGnosniff\x00\x00\x00\x00\x00\x00@\x00<h1>Hello world!</h1>"
```

Let any server spit this exchange at say `https://other.cdn.com/foo/bar.sxg`. Now, visiting this URL will result in <b>"Hello&nbsp;world!"</b> HTML with `https://foo.com/bar` in a browser's address bar - though no requests to `https://foo.com/bar` have been sent!

Successive reloads will force browser to factually send requests to `https://foo.com/bar`.

<!-- TODO: add image here -->
<img href="">

### A little caveat
Chrome will not proceed with a self-signed certificate - at least as long as its cbor representation is generated with dummy data for OCSP. To accomodate this, please launch the browser with the following flags:
```bash
chrome --user-data-dir=/tmp/udd\
       --ignore-certificate-errors-spki-list=`openssl x509 -noout -pubkey -in cert.pem | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64`
```

Note, that the browser might spit a warning `You are using unsupported command-line flag: --ignore-certificate-errors-spki-list` - just ignore it - the browser does support this flag (tested in versions 73 and 74).

<!-- TODO: Add contributions section -->
<!-- TODO: Add authors section -->
<!-- TODO: Add LICENSE authors section -->
